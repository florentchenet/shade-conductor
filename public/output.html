<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>shade-conductor | output</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#000;cursor:none}
canvas{display:block;width:100vw;height:100vh}
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
/**
 * shade-conductor OUTPUT view
 * Fullscreen shader canvas for projection / stream capture.
 * Connects to the same WebSocket as the main UI but renders
 * without any HUD, editor, or controls — pure visuals only.
 */
let WS_PORT = 3334;
const canvas = document.getElementById('c');
let gl, program, startTime, animFrame;
let tier = 'B'; // default WebGL1

// --- Uniforms state ---
const ext = new Float32Array(16);
const extXY = Array.from({length:4}, () => ({x:0, y:0}));
let bpm = 120, uTime = 0, uBeat = 0;
const params = new Float32Array(4);
const palette = {color1:[1,0,0.3], color2:[0,0.5,1], color3:[1,1,0], bg:[0.04,0.03,0.06]};
let intensity = 1, speed = 1;

// Audio state
const audio = {bass:0, mid:0, high:0, energy:0, peak:0, spectrum: new Float32Array(16)};

// Previous frame (Tier A only)
let fbos = [null, null], fboIdx = 0;

// --- WebGL init ---
function initGL() {
  gl = canvas.getContext('webgl2');
  if (gl) { tier = 'A'; } else {
    gl = canvas.getContext('webgl');
    tier = 'B';
  }
  if (!gl) { document.body.style.background = '#200'; return false; }
  resize();
  window.addEventListener('resize', resize);
  if (tier === 'A') initFBOs();
  return true;
}

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  gl.viewport(0, 0, canvas.width, canvas.height);
  if (tier === 'A') initFBOs();
}

function initFBOs() {
  for (let i = 0; i < 2; i++) {
    if (fbos[i]) { gl.deleteTexture(fbos[i].tex); gl.deleteFramebuffer(fbos[i].fb); }
    const tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, canvas.width, canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    const fb = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
    fbos[i] = {fb, tex};
  }
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
}

// --- Shader compilation ---
let currentFrag = null;

function compileShader(fragSrc) {
  const vs = gl.createShader(gl.VERTEX_SHADER);
  const vsrc = tier === 'A'
    ? '#version 300 es\nin vec2 a_pos;void main(){gl_Position=vec4(a_pos,0,1);}'
    : 'attribute vec2 a_pos;void main(){gl_Position=vec4(a_pos,0,1);}';
  gl.shaderSource(vs, vsrc);
  gl.compileShader(vs);

  const fs = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fs, fragSrc);
  gl.compileShader(fs);
  if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
    console.error('[output] frag compile:', gl.getShaderInfoLog(fs));
    gl.deleteShader(vs); gl.deleteShader(fs);
    return null;
  }

  const p = gl.createProgram();
  gl.attachShader(p, vs); gl.attachShader(p, fs);
  gl.linkProgram(p);
  if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
    console.error('[output] link:', gl.getProgramInfoLog(p));
    gl.deleteProgram(p); gl.deleteShader(vs); gl.deleteShader(fs);
    return null;
  }

  // Fullscreen quad
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW);
  const loc = gl.getAttribLocation(p, 'a_pos');
  gl.enableVertexAttribArray(loc);
  gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);

  if (program) gl.deleteProgram(program);
  program = p;
  currentFrag = fragSrc;
  uniformCache = cacheUniforms(p);
  return p;
}

// --- Uniform cache ---
// Uniform locations are cached per-program at compile time to avoid
// calling gl.getUniformLocation() every frame (expensive GPU roundtrip).
let uniformCache = null;

function cacheUniforms(p) {
  const u = {};
  const names = [
    'u_time', 'u_resolution', 'u_bpm', 'u_beat',
    'u_bass', 'u_mid', 'u_high', 'u_energy', 'u_peak',
    'u_color1', 'u_color2', 'u_color3', 'u_bg',
    'u_param1', 'u_param2', 'u_param3', 'u_param4',
    'u_intensity', 'u_speed', 'u_prevFrame',
  ];
  for (const name of names) {
    u[name] = gl.getUniformLocation(p, name);
  }
  // Arrays
  u.u_spectrum = gl.getUniformLocation(p, 'u_spectrum');
  u.u_ext = gl.getUniformLocation(p, 'u_ext');
  u.u_ext_xy = [];
  for (let i = 0; i < 4; i++) {
    u.u_ext_xy[i] = gl.getUniformLocation(p, `u_ext_xy[${i}]`);
  }
  return u;
}

// --- Uniform upload ---
function uploadUniforms() {
  if (!program || !uniformCache) return;
  gl.useProgram(program);
  const u = uniformCache;

  gl.uniform1f(u.u_time, uTime);
  gl.uniform2f(u.u_resolution, canvas.width, canvas.height);
  gl.uniform1f(u.u_bpm, bpm);
  gl.uniform1f(u.u_beat, uBeat);

  gl.uniform1f(u.u_bass, audio.bass);
  gl.uniform1f(u.u_mid, audio.mid);
  gl.uniform1f(u.u_high, audio.high);
  gl.uniform1f(u.u_energy, audio.energy);
  gl.uniform1f(u.u_peak, audio.peak);
  gl.uniform1fv(u.u_spectrum, audio.spectrum);

  gl.uniform3fv(u.u_color1, palette.color1);
  gl.uniform3fv(u.u_color2, palette.color2);
  gl.uniform3fv(u.u_color3, palette.color3);
  gl.uniform3fv(u.u_bg, palette.bg);

  gl.uniform1f(u.u_param1, params[0]);
  gl.uniform1f(u.u_param2, params[1]);
  gl.uniform1f(u.u_param3, params[2]);
  gl.uniform1f(u.u_param4, params[3]);
  gl.uniform1f(u.u_intensity, intensity);
  gl.uniform1f(u.u_speed, speed);
  gl.uniform1fv(u.u_ext, ext);

  for (let i = 0; i < 4; i++) {
    gl.uniform2f(u.u_ext_xy[i], extXY[i].x, extXY[i].y);
  }

  // Previous frame (Tier A)
  if (tier === 'A' && fbos[0]) {
    const prevIdx = 1 - fboIdx;
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, fbos[prevIdx].tex);
    gl.uniform1i(u.u_prevFrame, 0);
  }
}

// --- Render loop ---
function render(ts) {
  animFrame = requestAnimationFrame(render);
  if (!program) return;

  uTime = (ts - startTime) / 1000 * speed;
  uBeat = (uTime * bpm / 60) % 1;

  if (tier === 'A' && fbos[0]) {
    // Render to FBO
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbos[fboIdx].fb);
    uploadUniforms();
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    // Blit to screen
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    fboIdx = 1 - fboIdx;
  } else {
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    uploadUniforms();
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  }
}

// --- WebSocket ---
let ws, wsRetry;
function connectWS() {
  const url = `ws://${location.hostname || 'localhost'}:${WS_PORT}`;
  ws = new WebSocket(url);
  ws.onopen = () => { console.log('[output] ws connected'); clearTimeout(wsRetry); };
  ws.onclose = () => { wsRetry = setTimeout(connectWS, 2000); };
  ws.onerror = () => {};
  ws.onmessage = (ev) => {
    try { handleMsg(JSON.parse(ev.data)); } catch(e) {}
  };
}

function handleMsg(msg) {
  switch(msg.type) {
    case 'shader_push':
      compileShader(msg.code);
      break;
    case 'shader_crossfade':
      compileShader(msg.code);
      break;
    case 'ext_set':
      if (msg.channel >= 0 && msg.channel < 16) ext[msg.channel] = msg.value;
      break;
    case 'ext_xy_set':
      if (msg.channel >= 0 && msg.channel < 4) extXY[msg.channel] = {x: msg.x, y: msg.y};
      break;
    case 'bpm_set':
      if (msg.bpm > 0) bpm = msg.bpm;
      break;
    case 'param_set': {
      const name = msg.name;
      const value = msg.value;
      switch(name) {
        case 'u_param1': params[0] = value; break;
        case 'u_param2': params[1] = value; break;
        case 'u_param3': params[2] = value; break;
        case 'u_param4': params[3] = value; break;
        case 'u_intensity': intensity = value; break;
        case 'u_speed': speed = value; break;
      }
      break;
    }
    case 'palette_set':
      if (msg.colors) {
        if (msg.colors.color1) palette.color1 = msg.colors.color1;
        if (msg.colors.color2) palette.color2 = msg.colors.color2;
        if (msg.colors.color3) palette.color3 = msg.colors.color3;
        if (msg.colors.bg) palette.bg = msg.colors.bg;
      }
      break;
    case 'perform_blackout':
      compileShader(tier === 'A'
        ? '#version 300 es\nprecision mediump float;out vec4 o;void main(){o=vec4(0,0,0,1);}'
        : 'precision mediump float;void main(){gl_FragColor=vec4(0,0,0,1);}');
      break;
    case 'perform_flash':
      // Flash overlay not implemented in output view, but handle gracefully
      break;
    case 'audio_config':
      // Audio config — output view doesn't process audio locally
      break;
    case 'chapter_info':
      // Chapter info — no HUD in output view
      break;
    case 'get_state':
      if (ws && ws.readyState === 1) {
        ws.send(JSON.stringify({type:'state', data:{
          currentShader: null,
          fps: 60,
          tier,
          resolution: [canvas.width, canvas.height],
          audioActive: false,
        }}));
      }
      break;
    case 'capture_start':
    case 'capture_stop':
    case 'capture_screenshot':
      break;
    case 'shader_validate':
      break;
    case 'layer_push':
    case 'layer_remove':
    case 'layer_opacity':
      // Layer opacity — stored when layer compositing is implemented
      break;
    case 'audio_bind':
    case 'audio_unbind':
      break;
  }
}

// --- Init ---
if (initGL()) {
  startTime = performance.now();
  // Default: black until shader is pushed
  compileShader(tier === 'A'
    ? '#version 300 es\nprecision mediump float;out vec4 o;uniform float u_time;void main(){float t=u_time;o=vec4(vec3(0.01+0.005*sin(t)),1);}'
    : 'precision mediump float;uniform float u_time;void main(){float t=u_time;gl_FragColor=vec4(vec3(0.01+0.005*sin(t)),1);}');
  render(startTime);
  fetch('/api/config').then(function(r){return r.json();}).then(function(c){if(c.wsPort)WS_PORT=c.wsPort;}).catch(function(){}).finally(function(){connectWS();});
}
</script>
</body>
</html>
